-- ==============================================
-- 核心基础配置文件：Neovim 全局基础功能总开关
-- 作用：统一设置编辑器的显示、编码、缩进、操作逻辑等核心属性
-- 新手友好说明：所有配置均为「开箱即用」，无需修改；
-- 每个选项都附带「作用+原因+注意点+扩展知识」，彻底搞懂背后逻辑
-- ==============================================

-- 定义全局变量快捷键：简化后续代码书写，避免重复输入冗长的 vim.g / vim.opt
-- 核心知识点：
-- - vim.g：用于设置 Neovim 的全局变量（全局生效，所有窗口/文件共享）
-- - vim.opt：用于设置 Neovim 的编辑器选项（控制编辑器行为，支持局部覆盖）
-- 注意点：这只是变量赋值，不会改变任何功能，纯粹为了代码简洁
local g = vim.g
local opt = vim.opt

-- 设置语言环境为 en_US.UTF-8（必须带 UTF-8 后缀，绝对不能只写 en_US）
-- 原作者关键备注：之前仅设置为 en_US 时，复制粘贴命令（yGp，从光标处复制到文件末尾并粘贴）失效
-- 报错信息：E353: Nothing in register ""（寄存器为空，无法粘贴）
-- 深层原因：
-- 1. 缺少 UTF-8 编码支持时，Neovim 无法正确处理寄存器中的字符（尤其是中文、特殊符号）
-- 2. 寄存器是 Neovim 存储复制/剪切内容的临时空间，编码不兼容会导致内容丢失
-- 注意点：
-- - 无论系统是中文还是英文，都建议设为 en_US.UTF-8，避免编码冲突
-- - 若系统没有该语言包，Ubuntu 可通过 sudo apt install language-pack-en-base 安装
vim.cmd "language en_US.UTF-8"

-- 临时关闭语法高亮：syntax off 表示禁用内置语法高亮功能
-- 原作者设计思路：后续会通过插件（如 nvim-treesitter）启用更强大的语法高亮，这里先关闭内置的避免冲突
-- 扩展知识：
-- - 内置语法高亮：Neovim 自带，支持基础语言，但识别精度低、颜色单调
-- - 插件语法高亮（如 nvim-treesitter）：支持更多语言，能识别函数、变量、类型等细分语法，颜色更丰富
-- 注意点：这只是「临时关闭」，不是永久禁用，后续会被插件覆盖
vim.cmd "syntax off"

-- 设置全局编码格式为 UTF-8：控制 Neovim 内部处理字符的编码标准
-- 作用：确保 Neovim 能正确识别和显示中文、日文、特殊符号等非 ASCII 字符
-- 原因：UTF-8 是目前最通用的编码格式，兼容几乎所有字符，避免出现「乱码」
-- 注意点：
-- - 必须与下面的 fileencoding 保持一致，否则保存文件时可能出现编码不匹配
-- - 若打开旧文件出现乱码，可手动设置编码：:set fileencoding=utf-8
g.encoding = "UTF-8"

-- 设置文件编码格式为 utf-8：控制文件保存到硬盘时使用的编码
-- 作用：确保保存后的文件在其他编辑器（如 VS Code、记事本）中打开也不会乱码
-- 扩展知识：
-- - 常见编码格式对比：
--   - GBK：仅支持中文，Windows 记事本默认编码，跨系统打开易乱码
--   - UTF-8：支持所有字符，跨平台通用（推荐）
--   - ASCII：仅支持英文，无法显示中文
-- 注意点：小写的 utf-8 和大写的 UTF-8 效果一致，Neovim 会自动兼容
opt.fileencoding = "utf-8"

-- 获取当前活动窗口的高度：vim.fn.winheight(0) 是 Neovim 内置函数，0 表示「当前窗口」
-- 作用：为后续的滚动偏移配置提供动态值（根据窗口高度自动调整，不是固定值）
-- 扩展知识：vim.fn 是调用 Vimscript 内置函数的接口，类似桥梁，让 Lua 能使用 Vim 的功能
local win_height = vim.fn.winheight(0)

-- 设置垂直滚动偏移（scrolloff）：光标上下保留 (窗口高度-1)/2 行空白
-- 计算逻辑：math.floor 是向下取整，比如窗口高度 10 行时，(10-1)/2=4.5 → 取 4 行
-- 作用：滚动代码时，光标不会贴到屏幕顶部或底部，始终保留一定行数的上下文
-- 举个例子：
-- - 没有设置时：光标移到文件顶部，再向上滚动就会停在第一行，看不到上方内容（本来也没有）
-- - 设置后：光标移到文件顶部时，会自动保留 4 行空白，滚动时能提前看到下方即将出现的代码
-- 原因：避免滚动时「跳来跳去」，提升阅读流畅度，尤其适合长文件
-- 注意点：值越大，保留的空白越多，适合大屏幕；小屏幕可适当减小（如 2-3）
opt.scrolloff = math.floor((win_height - 1) / 2)

-- 设置水平滚动偏移（sidescrolloff）：光标左右保留 (窗口高度-1)/2 列空白
-- 作用：横向滚动代码时，光标不会贴到屏幕左侧或右侧，保留上下文
-- 适用场景：编写超长行代码（如没有自动换行时），横向滚动时能看到光标前后的内容
-- 扩展知识：与 scrolloff 对应，一个控制垂直方向，一个控制水平方向
opt.sidescrolloff = math.floor((win_height - 1) / 2)

-- 启用绝对行号显示：在代码左侧显示 1、2、3... 连续的行号
-- 作用：
-- 1. 快速定位代码位置（比如别人说「第 20 行有问题」，能直接找到）
-- 2. 配合相对行号使用，实现高效移动（如 5j 向下移动 5 行）
-- 注意点：开启后会占用左侧少量空间，若想节省空间可关闭（设为 false）
opt.number = true

-- 启用相对行号显示：光标所在行显示绝对行号，其他行显示与光标的「行数差」
-- 举个例子：
-- - 光标在第 10 行，上方第 8 行显示「2」（10-8=2），下方第 15 行显示「5」（15-10=5）
-- 作用：无需手动计算行数，直接用数字+方向键移动（如 3k 向上移动 3 行，效率极高）
-- 原因：这是 Neovim 高效编辑的核心技巧之一，减少手动计数的麻烦
-- 注意点：
-- - 必须配合绝对行号（number=true）使用，否则单独开启相对行号会混乱
-- - 新手初期可能不适应，用 1-2 天就能习惯，之后会觉得离不开
opt.relativenumber = true

-- 启用光标行高亮：光标所在的整行显示特殊背景色
-- 作用：瞬间定位光标位置，尤其在代码行数多、窗口大的场景下
-- 原因：避免在密密麻麻的代码中「找不到光标」，提升编辑效率
-- 扩展知识：
-- - 可自定义高亮颜色：vim.cmd "highlight CursorLine guibg=#333333"（深色背景）
-- - 若觉得高亮干扰，可关闭（设为 false）或调浅颜色
opt.cursorline = true

-- 始终显示符号列：代码左侧专门用于显示图标的列（如断点、LSP 错误提示、Git 变更标记）
-- 可选值说明：
-- - yes：始终显示，即使没有图标也保留空白列
-- - no：完全隐藏，有图标时也不显示
-- - auto：有图标时显示，无图标时隐藏
-- 作用：避免因图标显示/隐藏导致代码「左右晃动」（比如突然出现一个错误图标，代码整体右移）
-- 原因：保持编辑区域稳定，提升视觉体验
-- 注意点：会占用左侧 1-2 列空间，若不需要图标功能（如不调试、不用 LSP），可设为 auto
opt.signcolumn = "yes"

-- 显示 80 列参考线：在代码第 80 列显示一条竖线
-- 作用：提醒代码行不要超过 80 个字符，符合主流编程规范
-- 原因：
-- 1. 过长的代码行需要横向滚动才能看完，阅读体验差
-- 2. 很多团队的编码规范要求行宽不超过 80 列（如 Python PEP 8 规范）
-- 扩展知识：
-- - 可修改列数：如 opt.colorcolumn = "100"（设置为 100 列）
-- - 可隐藏参考线：opt.colorcolumn = ""（适合不需要行宽限制的场景）
-- 注意点：参考线仅为提醒，不会强制限制代码长度，超过也能正常编辑
opt.colorcolumn = "80"

-- 设置 Tab 键对应的空格数：1 个 Tab 键等于 4 个空格
-- 作用：统一 Tab 键的显示效果，避免不同编辑器对 Tab 的解析不一致
-- 原因：
-- - 有些编辑器默认 1 个 Tab 等于 2 个空格，有些是 4 个，容易导致代码缩进混乱
-- - 4 个空格是主流缩进标准（如 Python、Lua、Go 等语言推荐）
-- 注意点：该选项仅控制「显示效果」，不改变输入行为（后续 expandtab 才会控制 Tab 转空格）
opt.tabstop = 4

-- 设置自动缩进宽度：0 表示继承 tabstop 的值（即 4 个空格）
-- 自动缩进的定义：换行时，Neovim 自动为新行添加的缩进空格数（如 if 语句后换行，自动缩进）
-- 作用：统一换行后的缩进幅度，避免手动缩进的麻烦
-- 原因：
-- - 若设为固定值（如 2），会与 tabstop 不一致，导致缩进混乱
-- - 设为 0 可保持缩进规则统一（自动跟随 tabstop 的设置）
-- 注意点：0 是「继承」而非「禁用」，自动缩进功能依然生效
opt.shiftwidth = 0

-- 启用 Tab 键自动转换为空格：输入 Tab 键时，Neovim 自动替换为对应的空格（4 个）
-- 作用：彻底避免 Tab 字符导致的缩进混乱
-- 原因：
-- - Tab 字符（\t）在不同场景下显示宽度不同（如终端、编辑器、浏览器）
-- - 空格字符（ ）的显示效果在所有场景下都一致，适合团队协作
-- 扩展知识：
-- - 临时禁用转换：按 Ctrl+V 再按 Tab 键（插入原始 Tab 字符）
-- - 若需要保留 Tab 字符（如编写 Makefile），可临时关闭：opt.expandtab = false
-- 注意点：该设置仅影响输入的 Tab 键，文件中已有的 Tab 字符不会自动转换（需手动处理）
opt.expandtab = true

-- 缩进时自动对齐到最近的缩进级别：如 shiftwidth=4 时，缩进总是 4 的倍数
-- 作用：确保缩进的整齐性，避免出现不规则的缩进（如 3 个、5 个空格）
-- 举个例子：
-- - 没有设置时：手动缩进 3 个空格，Neovim 会保留 3 个
-- - 设置后：手动缩进 3 个空格，Neovim 会自动补到 4 个（最近的 4 的倍数）
-- 原因：不规则缩进会导致代码结构混乱，尤其在嵌套代码中（如 if 嵌套、函数嵌套）
opt.shiftround = true

-- 搜索时忽略大小写：输入小写字母也能匹配大写内容（如搜索 "test" 能匹配 "test"、"Test"、"TEST"）
-- 作用：提升搜索效率，无需手动切换大小写
-- 原因：日常搜索中，很少需要严格区分大小写，忽略大小写能减少重复搜索
-- 注意点：该选项会被 smartcase 覆盖（下文会讲），不是绝对的忽略大小写
opt.ignorecase = true

-- 智能大小写匹配：当搜索内容包含大写字母时，自动切换为「区分大小写」
-- 逻辑规则：
-- - 搜索内容全为小写（如 "test"）：忽略大小写（匹配 "test"、"Test" 等）
-- - 搜索内容包含大写（如 "Test"）：区分大小写（仅匹配 "Test"）
-- 作用：兼顾「模糊搜索」和「精确搜索」，无需手动切换配置
-- 原因：
-- - 想要模糊搜索时，直接输入小写即可
-- - 想要精确搜索时，输入包含大写的关键词即可
-- 注意点：必须配合 ignorecase=true 使用，否则该选项无效
opt.smartcase = true

-- 关闭搜索结果高亮：搜索完成后，不高亮显示所有匹配项
-- 作用：减少屏幕上的干扰元素，让注意力集中在编辑上
-- 原作者思路：默认的高亮颜色可能比较刺眼，且搜索完成后高亮意义不大
-- 扩展知识：
-- - 临时开启高亮：搜索后执行 :set hlsearch（或按 * 键再次搜索当前单词）
-- - 临时关闭高亮：按 :nohlsearch（或缩写 :noh）
-- 注意点：关闭后依然能正常搜索，只是不显示高亮，匹配结果会通过光标定位
opt.hlsearch = false

-- 设置命令行高度：1 行（底部输入命令的区域，如 :w 保存、:q 退出）
-- 作用：节省屏幕空间，1 行足够显示大部分命令
-- 原因：默认命令行高度为 1 行，除非需要输入超长命令，否则无需调整
-- 扩展知识：
-- - 增加高度：opt.cmdheight = 2（适合经常输入长命令的场景）
-- - 自动调整：opt.cmdheight = 0（Neovim 0.9+ 支持，命令行自动隐藏，输入时显示）
opt.cmdheight = 1

-- 设置命令历史窗口高度：1 行（按 : 后按上下键查看历史命令的窗口）
-- 作用：查看历史命令时，不会占用过多屏幕空间
-- 原因：日常查看历史命令只需看最近几条，1 行足够，多行会遮挡编辑区域
opt.cmdwinheight = 1

-- 启用文件外部修改自动读取：当文件被其他程序（如 VS Code、记事本）修改时，Neovim 自动刷新内容
-- 作用：避免编辑时使用其他工具修改了文件，Neovim 仍显示旧版本内容
-- 举个例子：
-- - 用 Neovim 打开 test.lua，同时用 VS Code 修改并保存了该文件
-- - 启用该选项后，Neovim 会自动加载 VS Code 修改后的内容
-- - 未启用时，Neovim 会显示旧内容，保存时可能覆盖 VS Code 的修改
-- 注意点：
-- - 若 Neovim 中已修改该文件但未保存，Neovim 会提示「文件已被外部修改，是否加载」
-- - 不会自动覆盖 Neovim 中的未保存修改，避免数据丢失
opt.autoread = true

-- 设置光标在行首/行尾时的换行行为：允许箭头键和方括号键切换行
-- 选项详解：
-- - <：左箭头键，在行首时，切换到上一行的行尾
-- - >：右箭头键，在行尾时，切换到下一行的行首
-- - [：左方括号键，在行首时，切换到上一行的行尾
-- - ]：右方括号键，在行尾时，切换到下一行的行首
-- 作用：光标移动更连贯，无需手动按换行键
-- 举个例子：
-- - 光标在第 1 行的行首，按左箭头键，会自动跳到第 0 行（不存在，所以不跳）
-- - 光标在第 1 行的行尾，按右箭头键，会自动跳到第 2 行的行首
-- 原因：减少光标移动的操作步骤，提升编辑流畅度
-- 扩展知识：可通过 :help 'whichwrap' 查看更多可配置的键位
opt.whichwrap = "<,>,[,]"

-- 允许隐藏已修改的缓冲区：切换文件时，无需强制保存当前修改的文件
-- 核心概念：缓冲区（buffer）是 Neovim 中打开的文件在内存中的副本
-- 作用：同时编辑多个文件时更灵活，不会被强制要求「先保存再切换」
-- 举个例子：
-- - 编辑文件 A 时修改了内容但未保存，想临时查看文件 B
-- - 启用该选项：可直接切换到 B，A 的修改会保存在缓冲区中（不丢失）
-- - 未启用：Neovim 会弹出提示「文件 A 已修改，是否保存？」，必须选择后才能切换
-- 注意点：
-- - 隐藏的修改缓冲区不会自动保存到硬盘，关闭 Neovim 时会提示是否保存
-- - 若想彻底放弃修改，可执行 :bdelete!（强制删除缓冲区）
opt.hidden = true

-- 启用鼠标支持：a 表示「所有模式」都支持鼠标操作（新手友好配置）
-- 模式说明（Neovim 核心模式，新手需了解）：
-- - 普通模式（Normal）：默认模式，用于移动光标、复制粘贴、执行命令（按 Esc 进入）
-- - 插入模式（Insert）：编辑文本的模式（按 i 进入，可输入代码/文字）
-- - 可视模式（Visual）：选择文本的模式（按 v 进入，可选中多行/多列文本）
-- - 命令模式（Command）：输入命令的模式（按 : 进入，如 :w 保存）
-- 作用：支持鼠标操作，降低新手入门难度（不用死记硬背所有快捷键）
-- 鼠标可执行的操作：
-- - 普通模式：鼠标点击移动光标、滚轮滚动代码
-- - 插入模式：鼠标点击调整光标位置（比如想在中间插入文字，直接点过去）
-- - 可视模式：鼠标拖动选择文本（和 VS Code、记事本操作一致）
-- 注意点：
-- - 若想禁用鼠标支持（纯键盘流）：opt.mouse = ""
-- - 终端不支持鼠标时，该配置自动失效，不会报错
opt.mouse = "a"

-- 设置鼠标模式为「extend」：扩展模式，优化鼠标选择和拖动体验
-- 核心效果（新手能直观感受到）：
-- - 鼠标拖动选择文本时，不会自动切换模式（比如不会从普通模式跳到可视模式后卡住）
-- - 选择文本后，点击其他位置可直接取消选择，无需按 Esc 键
-- - 按住 Ctrl 键+鼠标点击，可跳转到函数/变量的定义（部分插件需配合）
-- 作用：让鼠标操作更符合主流编辑器（如 VS Code、Sublime）的习惯，降低适应成本
-- 扩展知识：Neovim 鼠标模式可选值：
-- - "extend"：扩展模式（推荐，新手友好）
-- - "popup"：弹出模式（点击右键显示菜单）
-- - "expr"：表达式模式（高级用户自定义）
-- 注意点：若觉得鼠标操作不符合预期，可改为默认模式：opt.mousemodel = "popup"
opt.mousemodel = "extend"

-- 禁用备份文件：不会生成 .bak 后缀的备份文件
-- 备份文件说明：默认情况下，Neovim 保存文件时会创建一个备份（比如 test.lua → test.lua.bak）
-- 作用：避免生成多余的备份文件，占用磁盘空间，且容易混淆原文件
-- 原因：
-- - 备份文件的作用是防止保存失败导致数据丢失，但现代编辑器（包括 Neovim）稳定性足够，很少出现这种情况
-- - 若需要备份，可通过 Git 版本控制（如 git commit）实现，比本地备份更可靠
-- 注意点：
-- - 临时启用备份：:set backup ；重新禁用：:set nobackup
-- - 若担心数据丢失，建议使用 Git 或云盘同步文件
opt.backup = false

-- 禁用写入时备份：保存文件过程中不会生成临时备份
-- 写入时备份说明：保存文件时，Neovim 会先创建一个临时备份，保存成功后再删除
-- 作用：避免保存过程中生成临时文件（如 .test.lua.swp），减少文件混乱
-- 原因：临时备份文件仅在保存瞬间存在，正常情况下会自动删除，但异常退出（如强制关闭终端）时可能残留
-- 残留的临时文件会导致下次打开时提示「是否恢复」，新手容易困惑
-- 注意点：禁用后不影响正常保存，仅取消保存过程中的临时备份步骤
opt.writebackup = false

-- 禁用交换文件：不会生成 .swp 后缀的交换文件
-- 交换文件说明：交换文件是 Neovim 用于「崩溃恢复」的临时文件（比如编辑时终端崩溃，下次打开可恢复内容）
-- 作用：避免生成多余的 .swp 文件，减少磁盘 clutter（文件杂乱）
-- 原因：
-- - 交换文件会一直存在于编辑过程中，占用磁盘空间，且文件名带点（隐藏文件），清理时容易遗漏
-- - 新手很少遇到「崩溃恢复」场景，即使遇到，未保存的内容也可通过 Neovim 自带的恢复功能尝试找回
-- 注意点：
-- - 临时启用交换文件：:set swapfile ；重新禁用：:set noswapfile
-- - 若需要崩溃恢复功能，可启用，但要定期清理残留的 .swp 文件
opt.swapfile = false

-- 设置按键组合超时时间：500 毫秒（0.5 秒）
-- 按键组合说明：需要连续按多个键的操作（如 <leader>w 保存、gd 跳转到定义）
-- 作用：控制按键组合的「响应等待时间」，避免等待过久或触发过快
-- 举个例子：
-- - 按 <leader>（默认是 \ 键）后，500 毫秒内按 w ，会执行保存命令
-- - 超过 500 毫秒未按后续键，会视为单独按了 <leader> 键，不执行组合命令
-- 原因：
-- - 超时时间太短（如 200 毫秒）：新手按键速度慢，容易错过时间，组合命令无法触发
-- - 超时时间太长（如 2000 毫秒）：按错键后需要等很久才能恢复，影响操作流畅度
-- 500 毫秒是兼顾新手和老手的合理值，大部分人能适应
-- 注意点：
-- - 新手可适当延长（如 800 毫秒）：opt.timeoutlen = 800
-- - 老手可缩短（如 300 毫秒）：opt.timeoutlen = 300
opt.timeoutlen = 500

-- 水平分割窗口时，新窗口在下方
-- 窗口分割说明：使用 :split 命令（水平分割，上下两个窗口）打开新文件时的位置
-- 作用：符合视觉习惯，新窗口在下方，不遮挡当前编辑的内容
-- 举个例子：
-- - 当前在编辑 A.lua（上方窗口），执行 :split B.lua ，B.lua 会在下方打开
-- - 视线不用上移，可继续关注上方的 A.lua，同时查看下方的 B.lua
-- 原因：默认情况下，新窗口可能在上方，遮挡当前编辑的内容，需要手动调整窗口位置
-- 注意点：
-- - 临时改为上方分割：:set nosplitbelow ；恢复下方：:set splitbelow
-- - 垂直分割窗口（:vsplit）的位置由 splitright 控制（下文配置）
opt.splitbelow = true

-- 垂直分割窗口时，新窗口在右侧
-- 窗口分割说明：使用 :vsplit 命令（垂直分割，左右两个窗口）打开新文件时的位置
-- 作用：符合视觉习惯，新窗口在右侧，不遮挡当前编辑的内容
-- 举个例子：
-- - 当前在编辑 A.lua（左侧窗口），执行 :vsplit B.lua ，B.lua 会在右侧打开
-- - 左侧的 A.lua 完整显示，可同时编辑 A.lua 和查看右侧的 B.lua（如复制代码）
-- 原因：默认情况下，新窗口可能在左侧，遮挡当前编辑的内容，影响操作
-- 注意点：
-- - 临时改为左侧分割：:set nosplitright ；恢复右侧：:set splitright
-- - 配合 splitbelow 使用，分割窗口的位置更符合直觉
opt.splitright = true

-- 启用真彩色支持：让 Neovim 能显示更多颜色，支持丰富的主题配色
-- 真彩色说明：真彩色（24 位色）可显示约 1677 万种颜色，普通彩色（8 位色）仅能显示 256 种颜色
-- 作用：
-- - 主题配色更细腻、鲜艳（如深色主题的渐变效果、语法高亮的多种颜色区分）
-- - 支持更多高质量的 Neovim 主题（如 Catppuccin、Tokyonight、Dracula 等）
-- 原因：新手使用 Neovim 时，美观的主题能提升使用体验，降低入门抵触情绪
-- 注意点：
-- - 需终端支持真彩色（大部分现代终端都支持，如 iTerm2、Alacritty、Kitty、Windows Terminal）
-- - 验证终端是否支持：在终端输入 echo $COLORTERM ，输出 "truecolor" 表示支持
-- - 若终端不支持真彩色，该配置自动降级为 256 色，不会报错
-- - 临时禁用真彩色：:set notermguicolors ；重新启用：:set termguicolors
opt.termguicolors = true

-- 搜索计数前不显示 "W" 字符：简化搜索计数提示
-- 背景说明：默认情况下，搜索匹配多个结果时，Neovim 会在底部显示 "W1/5"（表示第 1 个匹配，共 5 个）
-- 作用：去掉多余的 "W" 字符，显示为 "1/5"，更简洁直观
-- 原因："W" 字符无实际意义，仅为 Vim 历史遗留标识，去掉后不影响功能，且界面更干净
-- 注意点：仅影响搜索计数的显示格式，不改变搜索功能本身
opt.shortmess = vim.o.shortmess .. "s"

-- 设置补全菜单最大高度：最多显示 16 行补全选项
-- 补全菜单说明：输入代码时，Neovim 或插件（如 nvim-cmp）弹出的自动补全选项列表（如函数、变量、关键字）
-- 作用：
-- - 避免补全菜单过高，遮挡过多编辑区域（比如屏幕小的时候，16 行不会占满屏幕）
-- - 同时显示足够多的补全选项，减少上下滚动查找的麻烦
-- 原因：
-- - 补全菜单太高（如 30 行）会遮挡大部分代码，影响查看上下文
-- - 太低（如 8 行）会导致补全选项显示不全，需要频繁滚动
-- 16 行是兼顾「显示数量」和「屏幕占用」的合理值
-- 注意点：
-- - 新手可根据屏幕大小调整：小屏幕设为 10（opt.pumheight = 10），大屏幕设为 20（opt.pumheight = 20）
-- - 临时调整：:set pumheight=12
opt.pumheight = 16

-- 始终显示标签栏：顶部显示已打开文件的标签（类似浏览器标签页）
-- 标签栏说明：标签栏会列出所有已打开的缓冲区（文件），点击可快速切换
-- 作用：
-- - 直观查看当前打开的所有文件，不用记缓冲区编号
-- - 快速切换文件（点击标签即可），提升多文件编辑效率
-- 原因：
-- - 若设为自动显示（opt.showtabline=1），切换文件时标签栏会「闪现」（显示/隐藏切换），影响视觉体验
-- - 配合 bufferline 插件使用时，提前显示标签栏可避免插件加载时的「闪烁」问题
-- 可选值说明：
-- - 0：永远隐藏标签栏
-- - 1：只有打开多个文件时才显示
-- - 2：始终显示（推荐）
-- 注意点：
-- - 临时隐藏标签栏：:set showtabline=0 ；恢复显示：:set showtabline=2
-- - 标签栏会占用顶部 1 行空间，若想节省空间可设为 1
opt.showtabline = 2

-- 设置标签栏为空：避免默认标签栏显示多余内容
-- 背景说明：默认标签栏会显示文件路径、缓冲区编号等信息，可能比较杂乱
-- 作用：清空默认标签内容，为后续插件（如 bufferline）预留标签栏空间
-- 原因：后续安装 bufferline 等标签管理插件后，会自定义标签显示样式（如文件名、图标、修改状态）
-- 提前清空默认内容，可避免插件样式与默认样式冲突
-- 注意点：若不安装标签插件，标签栏会显示为空，可手动设置标签格式（如 opt.tabline = "%f" 显示文件名）
opt.tabline = "%!''"

-- 禁用模式显示：不在底部状态栏显示当前编辑模式（如 -- INSERT --、-- NORMAL --）
-- 模式显示说明：默认情况下，切换到插入模式、可视模式时，底部会显示对应的模式名称
-- 作用：节省状态栏空间，让状态栏只显示关键信息（如行号、文件编码、Git 状态）
-- 原因：
-- - 新手熟悉模式后，可通过操作习惯判断当前模式（如插入模式能输入文字，普通模式能移动光标）
-- - 后续安装状态栏插件（如 lualine）后，会自定义模式显示样式（更美观、简洁），避免重复显示
-- 注意点：
-- - 新手若不熟悉模式，可暂时开启：:set showmode ；熟悉后再关闭
-- - 忘记当前模式时，按 Esc 键可回到普通模式，无需依赖显示
opt.showmode = false

-- 设置数字格式：支持二进制、十六进制、字母序列
-- 数字格式说明：输入数字时，Neovim 识别的数字类型，影响递增/递减操作（如 Ctrl+A 递增、Ctrl+X 递减）
-- 可选值说明：
-- - bin：二进制数字（0b 开头，如 0b101 表示 5）
-- - hex：十六进制数字（0x 开头，如 0x1F 表示 31）
-- - alpha：字母序列（如 a→b→c、A→B→C、aa→ab→ac）
-- 作用：扩展递增/递减功能，支持更多场景
-- 举个例子：
-- - 光标在 "a" 上按 Ctrl+A，会变成 "b"；在 "0b10" 上按 Ctrl+A，会变成 "0b11"
-- - 编写配置文件、枚举值时，可快速递增字母或进制数字
-- 原因：默认仅支持十进制数字，扩展后能满足更多编辑场景，提升效率
-- 注意点：仅影响递增/递减操作，不改变数字的显示和保存格式
opt.nrformats = "bin,hex,alpha"

-- 设置折叠级别：99 表示最大折叠级别（几乎不自动折叠）
-- 折叠说明：折叠是将代码块（如函数、循环、类）收缩成一行的功能（方便查看整体结构）
-- 折叠级别说明：数字越大，允许折叠的代码块越细（99 表示支持所有层级的折叠）
-- 作用：避免代码被自动折叠，新手能看到完整的代码结构，不遗漏内容
-- 原因：
-- - 新手对代码结构不熟悉，自动折叠可能导致找不到代码（如函数被折叠后看不到内部逻辑）
-- - 设为 99 后，代码默认完全展开，需要折叠时可手动操作（如 zc 折叠、zo 展开）
-- 注意点：
-- - 临时调整折叠级别：:set foldlevel=5 （仅折叠 5 级以上的代码块）
-- - 折叠操作快捷键（新手必记）：
--   - zc：折叠当前代码块
--   - zo：展开当前代码块
--   - zR：展开所有代码块
--   - zM：折叠所有代码块
opt.foldlevel = 99

-- 设置初始折叠级别：99 表示打开文件时完全展开所有代码
-- 作用：打开文件后直接看到完整代码，不用手动展开，适合新手
-- 原因：默认初始折叠级别较低（如 0），打开文件后大部分代码被折叠，新手需要逐一展开，操作繁琐
-- 注意点：若想打开文件时自动折叠（如查看大型项目代码结构），可设为 0（opt.foldlevelstart = 0）
opt.foldlevelstart = 99

-- 禁用折叠功能：彻底关闭代码折叠，所有代码始终完全展开
-- 作用：避免新手误触折叠快捷键导致代码「消失」，减少困惑
-- 原因：新手初期重点在编写和理解代码，折叠功能暂时用不上，反而可能造成操作干扰
-- 注意点：
-- - 后续熟悉 Neovim 后，可启用折叠功能：:set foldenable ；重新禁用：:set nofoldenable
-- - 启用后需配合折叠级别（foldlevel）和折叠方法（如 treesitter 折叠）使用
opt.foldenable = false

-- 设置状态栏样式：3 表示全局统一状态栏（所有窗口共享一个状态栏）
-- 状态栏说明：底部显示文件信息、行号、编码、模式等内容的区域
-- 可选值说明：
-- - 0：禁用状态栏
-- - 1：每个窗口都有独立状态栏
-- - 2：始终显示状态栏（每个窗口独立）
-- - 3：全局统一状态栏（所有窗口共享底部一个状态栏，Neovim 0.7+ 支持）
-- 作用：
-- - 节省屏幕空间（多个窗口时只显示一个状态栏，不重复占用空间）
-- - 统一显示关键信息（如当前激活窗口的文件状态），避免信息杂乱
-- 原因：多窗口编辑时，每个窗口都显示状态栏会占用大量底部空间，尤其小屏幕场景下影响编辑区域
-- 注意点：
-- - 需 Neovim 0.7 及以上版本支持，低版本会自动降级为 2
-- - 配合状态栏插件（如 lualine）使用时，全局状态栏样式更统一美观
opt.laststatus = 3

-- Windows 系统专用配置：启用 shellslash（斜杠路径分隔符）
-- 背景说明：Windows 系统默认用反斜杠（\）作为路径分隔符（如 C:\Users\test）
-- Linux/Mac 用斜杠（/）（如 /home/test）
-- 作用：让 Windows 系统的 Neovim 支持斜杠路径（如 /home/test），与 Linux/Mac 保持一致
-- 原因：
-- - 大部分 Neovim 插件和配置文件都默认使用斜杠路径，避免 Windows 系统因路径分隔符不兼容报错
-- - 编写跨平台配置时，无需单独适配 Windows 路径，减少配置复杂度
-- 注意点：
-- - 该配置通过 require("core.utils").is_windows 判断是否为 Windows 系统，需确保 core.utils 模块存在
-- - Linux/Mac 系统会自动跳过该配置，无需修改
if require("core.utils").is_windows then
    opt.shellslash = true
end

-- 创建自动命令：打开终端窗口时，禁用行号显示
-- 自动命令说明：autocmd 是 Neovim 的「事件触发机制」，当指定事件发生时，执行预设操作
-- 事件说明：TermOpen 事件 → 打开终端窗口（如 :terminal 命令）时触发
-- 作用：终端窗口不需要行号（终端是输入命令的地方，行号无意义），禁用后更简洁
-- 原因：终端窗口显示行号会占用左侧空间，且与终端输出内容冲突，影响视觉体验
-- 操作说明：
-- - vim.wo ：窗口局部选项（仅对当前终端窗口生效，不影响其他编辑窗口）
-- - vim.wo.number = false ：禁用绝对行号
-- - vim.wo.relativenumber = false ：禁用相对行号
-- 注意点：其他编辑窗口（如打开 lua 文件）的行号显示不受影响
vim.api.nvim_create_autocmd("TermOpen", {
    callback = function()
        vim.wo.number = false
        vim.wo.relativenumber = false
    end,
})

-- 初始禁用 shada 文件：启动时不加载 shada 历史文件
-- shada 文件说明：shada（Shared Data）是 Neovim 存储历史数据的文件，包括：
-- - 命令历史、搜索历史
-- - 寄存器内容（复制粘贴的内容）
-- - 打开过的文件位置
-- 作用：加快 Neovim 启动速度，避免加载历史数据导致启动变慢
-- 原因：新手初期历史数据较少，加载 shada 文件的收益不大，反而可能拖慢启动
-- 注意点：该配置仅为「初始禁用」，后续会通过自动命令加载（下文配置）
opt.shadafile = "NONE"

-- 创建自动命令：第一次进入命令行/命令窗口时，加载 shada 文件
-- 事件说明：
-- - CmdlineEnter ：进入命令行模式（按 : 或 / 时触发）
-- - CmdwinEnter ：进入命令窗口（按 q: 查看命令历史时触发）
-- - once = true ：该自动命令仅执行一次（避免重复加载）
-- 作用：启动时不加载 shada，首次使用命令行时再加载，兼顾启动速度和历史数据保留
-- 逻辑说明：
-- 1. 计算 shada 文件路径：stdpath("state") 是 Neovim 的状态文件目录（如 ~/.local/state/nvim）
-- 2. 设置 shadafile 路径：指定加载的 shada 文件位置
-- 3. 执行 rshada! 命令：强制加载 shada 文件（! 表示覆盖当前历史数据）
-- 注意点：加载后，之前的命令历史、寄存器内容会恢复，不影响后续使用
vim.api.nvim_create_autocmd({ "CmdlineEnter", "CmdwinEnter" }, {
    once = true,
    callback = function()
        local shada = vim.fs.joinpath(vim.fn.stdpath "state", "shada/main.shada")
        vim.o.shadafile = shada
        vim.cmd("rshada! " .. shada)
    end,
})

-- 创建自动命令：进入命令窗口时，自动进入插入模式并禁用行号
-- 事件说明：CmdwinEnter → 进入命令窗口（按 q: 查看/编辑命令历史时触发）
-- 作用：
-- 1. 自动进入插入模式（startinsert）：可直接编辑命令历史，不用手动按 i 进入插入模式
-- 2. 禁用行号：命令窗口显示命令历史，行号无意义，禁用后更简洁
-- 原因：命令窗口的核心用途是编辑和执行历史命令，自动进入插入模式能减少操作步骤
-- 注意点：退出命令窗口按 Esc 即可，回到普通模式后可关闭命令窗口（:q）
vim.api.nvim_create_autocmd("CmdwinEnter", {
    callback = function()
        vim.cmd "startinsert"
        vim.wo.number = false
        vim.wo.relativenumber = false
    end,
})

-- 创建自动命令：新建窗口时，禁用自动换行
-- 事件说明：WinNew → 新建窗口（如 :split、:vsplit 或打开新文件时触发）
-- 自动换行说明：自动换行（wrap）是指代码行过长时，自动折到下一行显示
-- 作用：禁用自动换行，代码行保持原样，避免折行导致的代码结构混乱
-- 原因：
-- - 自动换行后，代码行可能被拆分成多行，影响代码阅读（如长函数参数、长字符串）
-- - 新手编写代码时，应养成「行宽不超过 80 列」的习惯，禁用自动换行可强制提醒
-- 注意点：
-- - 临时启用自动换行：:set wrap ；重新禁用：:set nowrap
-- - 长代码行可通过横向滚动查看（按 Ctrl+E 向下滚动、Ctrl+Y 向上滚动）
vim.api.nvim_create_autocmd("WinNew", {
    callback = function()
        vim.wo.wrap = false
    end
})

-- 为第一个窗口禁用自动换行：WinNew 事件不会触发第一个窗口，单独设置
-- 作用：确保打开 Neovim 时，第一个窗口（默认窗口）也禁用自动换行，保持配置统一
-- 原因：WinNew 事件仅在「新建窗口」时触发，启动时的第一个窗口不会触发该事件
-- 若不单独设置，第一个窗口会启用默认的自动换行，导致配置不一致
-- 注意点：与上面的自动命令配合，实现「所有窗口都禁用自动换行」
vim.wo.wrap = false